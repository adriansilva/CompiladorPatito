PROGRAMA p;
VAR INT: arr[10];

FUNCION INT binarySearch(INT arr[10], INT x, INT low, INT high){
    VAR INT: mid = (low+high+1)/2;

    SI (low == high-1) ENTONCES{
      SI (low == -1) ENTONCES{
          REGRESA low;
      }
      SI (arr[low] == x) ENTONCES{
        REGRESA low;
      }
      SINO{
        REGRESA -1;
      }
    }

    SI(arr[mid]>x)ENTONCES{
      high = mid;
    }
    SINO{
      low = mid;
    }
    REGRESA binarySearch(arr,x,low,high);
}

FUNCION VOID quickSort(INT arr[10], INT low, INT high, INT x){
    VAR INT: pi, stack[10] = 0, top = -1, i, pivot, j, temp;

    top = top + 1;
    stack[top] = low;
    top = top + 1;
    stack[top] = high;

    MIENTRAS (top>=0) HAZ{
      high = stack[top];
      top = top - 1;
      low = stack[top];
      top = top - 1;


      %% Inicia Partition

      i = low - 1;
      pivot = arr[high];
      j = low;

      DESDE j HASTA high HAZ{
        SI (arr[j] <= pivot) ENTONCES{
          i = i+1;
          temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
        }
      }

      temp = arr[i+1];
      arr[i+1] = arr[high];
      arr[high] = temp;

      pi = i + 1;
      %%Termina partition

      SI (pi-1>low) ENTONCES{
        top = top + 1;
        stack[top] = low;
        top = top + 1;
        stack[top] = pi - 1;
      }

      SI (pi+1<high) ENTONCES{
        top = top + 1;
        stack[top] = pi + 1;
        top = top + 1;
        stack[top] = high;
      }
    }
    ESCRIBE(arr);
    ESCRIBE(binarySearch(arr,x,-1,10));
}

PRINCIPAL(){
    VAR INT: i = 0, x;
    arr[0] = 14;
    arr[1] = 50;
    arr[2] = 4;
    arr[3] = 2;
    arr[4] = -17;
    arr[5] = -0;
    arr[6] = 1000;
    arr[7] = -2;
    arr[8] = 15;
    arr[9] = 6;

    x = 50;

    quickSort(arr,0,9,x);
}
